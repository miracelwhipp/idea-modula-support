// This is a generated file. Not intended for manual editing.
package org.modula.parsing.modula.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import org.modula.parsing.psi.ModulaElementType;
import org.modula.helpers.index.stub.element.types.ConstantStubElementType;
import org.modula.helpers.index.stub.element.types.EnumerationMemberStubElementType;
import org.modula.helpers.index.stub.element.types.ModuleStubElementType;
import org.modula.helpers.index.stub.element.types.ParameterStubElementType;
import org.modula.helpers.index.stub.element.types.ProcedureStubElementType;
import org.modula.helpers.index.stub.element.types.TypeStubElementType;
import org.modula.helpers.index.stub.element.types.VariableStubElementType;
import org.modula.parsing.psi.ModulaTokenType;
import org.modula.parsing.modula.psi.impl.*;

public interface TokenModulaTypes {

  IElementType ACTUAL_PARAMETERS = new ModulaElementType("ACTUAL_PARAMETERS");
  IElementType ARRAY_RANGE_TYPE = new ModulaElementType("ARRAY_RANGE_TYPE");
  IElementType ARRAY_TYPE = new ModulaElementType("ARRAY_TYPE");
  IElementType ASSIGNMENT = new ModulaElementType("ASSIGNMENT");
  IElementType ATTRIBUTE = new ModulaElementType("ATTRIBUTE");
  IElementType BASIC_TYPE = new ModulaElementType("BASIC_TYPE");
  IElementType BLOCK = new ModulaElementType("BLOCK");
  IElementType CASE_LABELS = new ModulaElementType("CASE_LABELS");
  IElementType CASE_LABEL_LIST = new ModulaElementType("CASE_LABEL_LIST");
  IElementType CASE_STATEMENT = new ModulaElementType("CASE_STATEMENT");
  IElementType CASE_STATEMENTS = new ModulaElementType("CASE_STATEMENTS");
  IElementType COMPILATION_UNIT = new ModulaElementType("COMPILATION_UNIT");
  IElementType COMPLEX_LITERAL = new ModulaElementType("COMPLEX_LITERAL");
  IElementType CONSTANT_DECLARATION = new ConstantStubElementType("CONSTANT_DECLARATION");
  IElementType DECLARATION = new ModulaElementType("DECLARATION");
  IElementType DEFINITIONS = new ModulaElementType("DEFINITIONS");
  IElementType DEFINITION_MODULE = new ModulaElementType("DEFINITION_MODULE");
  IElementType DESIGNATOR = new ModulaElementType("DESIGNATOR");
  IElementType ELEMENT = new ModulaElementType("ELEMENT");
  IElementType ENUMERATION_DEFINITION = new ModulaElementType("ENUMERATION_DEFINITION");
  IElementType ENUMERATION_MEMBER_DEFINITION = new EnumerationMemberStubElementType("ENUMERATION_MEMBER_DEFINITION");
  IElementType EXPORT_CLAUSE = new ModulaElementType("EXPORT_CLAUSE");
  IElementType EXPORT_NAME_DECLARATION = new ModulaElementType("EXPORT_NAME_DECLARATION");
  IElementType EXPRESSION = new ModulaElementType("EXPRESSION");
  IElementType EXP_LIST = new ModulaElementType("EXP_LIST");
  IElementType FACTOR = new ModulaElementType("FACTOR");
  IElementType FIELD_LIST = new ModulaElementType("FIELD_LIST");
  IElementType FIELD_LIST_SEQUENCE = new ModulaElementType("FIELD_LIST_SEQUENCE");
  IElementType FORMAL_PARAMETERS = new ModulaElementType("FORMAL_PARAMETERS");
  IElementType FORMAL_TYPE = new ModulaElementType("FORMAL_TYPE");
  IElementType FORMAL_TYPE_LIST = new ModulaElementType("FORMAL_TYPE_LIST");
  IElementType FOR_STATEMENT = new ModulaElementType("FOR_STATEMENT");
  IElementType FP_SECTION = new ModulaElementType("FP_SECTION");
  IElementType IDENT = new ModulaElementType("IDENT");
  IElementType IDENT_LIST = new ModulaElementType("IDENT_LIST");
  IElementType IF_STATEMENT = new ModulaElementType("IF_STATEMENT");
  IElementType IGNORED = new ModulaElementType("IGNORED");
  IElementType IMPORT_CLAUSE = new ModulaElementType("IMPORT_CLAUSE");
  IElementType IMPORT_SYMBOL = new ModulaElementType("IMPORT_SYMBOL");
  IElementType INTEGER_LITERAL = new ModulaElementType("INTEGER_LITERAL");
  IElementType LOOP_STATEMENT = new ModulaElementType("LOOP_STATEMENT");
  IElementType MACRO_DECLARATION = new ModulaElementType("MACRO_DECLARATION");
  IElementType MODULE_DECLARATION = new ModulaElementType("MODULE_DECLARATION");
  IElementType MODULE_HEADER = new ModuleStubElementType("MODULE_HEADER");
  IElementType MODULE_IMPORT = new ModulaElementType("MODULE_IMPORT");
  IElementType MODULE_IMPORT_CLAUSE = new ModulaElementType("MODULE_IMPORT_CLAUSE");
  IElementType MODULE_NAME = new ModulaElementType("MODULE_NAME");
  IElementType NUMBER = new ModulaElementType("NUMBER");
  IElementType PARAMETER_IDENT_LIST = new ModulaElementType("PARAMETER_IDENT_LIST");
  IElementType PARAMETER_MODIFIER = new ModulaElementType("PARAMETER_MODIFIER");
  IElementType PARAMETER_NAME = new ParameterStubElementType("PARAMETER_NAME");
  IElementType PARAMETER_VALUE_MODIFIER = new ModulaElementType("PARAMETER_VALUE_MODIFIER");
  IElementType POINTER_TYPE = new ModulaElementType("POINTER_TYPE");
  IElementType PRIORITY = new ModulaElementType("PRIORITY");
  IElementType PROCEDURE_ATTRIBUTES = new ModulaElementType("PROCEDURE_ATTRIBUTES");
  IElementType PROCEDURE_CALL = new ModulaElementType("PROCEDURE_CALL");
  IElementType PROCEDURE_DECLARATION = new ModulaElementType("PROCEDURE_DECLARATION");
  IElementType PROCEDURE_HEADING = new ProcedureStubElementType("PROCEDURE_HEADING");
  IElementType PROCEDURE_MODIFIERS = new ModulaElementType("PROCEDURE_MODIFIERS");
  IElementType PROCEDURE_TYPE = new ModulaElementType("PROCEDURE_TYPE");
  IElementType PROGRAM_HEADER = new ModulaElementType("PROGRAM_HEADER");
  IElementType PROGRAM_MODULE = new ModulaElementType("PROGRAM_MODULE");
  IElementType QUALIDENT = new ModulaElementType("QUALIDENT");
  IElementType REAL_LITERAL = new ModulaElementType("REAL_LITERAL");
  IElementType RECORD_TYPE = new ModulaElementType("RECORD_TYPE");
  IElementType RECOVER_END_OF_STATEMENT = new ModulaElementType("RECOVER_END_OF_STATEMENT");
  IElementType RECOVER_WHILE_STATEMENT = new ModulaElementType("RECOVER_WHILE_STATEMENT");
  IElementType REPEAT_STATEMENT = new ModulaElementType("REPEAT_STATEMENT");
  IElementType SET_EXPRESSION = new ModulaElementType("SET_EXPRESSION");
  IElementType SET_TYPE = new ModulaElementType("SET_TYPE");
  IElementType SIMPLE_EXPRESSION = new ModulaElementType("SIMPLE_EXPRESSION");
  IElementType SIMPLE_TYPE = new ModulaElementType("SIMPLE_TYPE");
  IElementType STATEMENT = new ModulaElementType("STATEMENT");
  IElementType STATEMENT_SEQUENCE = new ModulaElementType("STATEMENT_SEQUENCE");
  IElementType STONY_BROOK_TYPE = new ModulaElementType("STONY_BROOK_TYPE");
  IElementType STRING = new ModulaElementType("STRING");
  IElementType SUB_RANGE_TYPE = new ModulaElementType("SUB_RANGE_TYPE");
  IElementType SYMBOL_IMPORT_CLAUSE = new ModulaElementType("SYMBOL_IMPORT_CLAUSE");
  IElementType TERM = new ModulaElementType("TERM");
  IElementType TYPES = new ModulaElementType("TYPES");
  IElementType TYPE_DECLARATION = new ModulaElementType("TYPE_DECLARATION");
  IElementType TYPE_DEFINITION = new TypeStubElementType("TYPE_DEFINITION");
  IElementType VARIABLE_DECLARATION = new ModulaElementType("VARIABLE_DECLARATION");
  IElementType VARIABLE_MODIFIERS = new ModulaElementType("VARIABLE_MODIFIERS");
  IElementType VARIABLE_NAME_DEFINITION = new VariableStubElementType("VARIABLE_NAME_DEFINITION");
  IElementType VARIANT = new ModulaElementType("VARIANT");
  IElementType WHILE_STATEMENT = new ModulaElementType("WHILE_STATEMENT");
  IElementType WITH_STATEMENT = new ModulaElementType("WITH_STATEMENT");

  IElementType AND = new ModulaTokenType("AND");
  IElementType ANYTHING = new ModulaTokenType("ANYTHING");
  IElementType ARRAY = new ModulaTokenType("ARRAY");
  IElementType ASSEMBLER = new ModulaTokenType("ASSEMBLER");
  IElementType ASSIGNMENT_OPERATOR = new ModulaTokenType("ASSIGNMENT_OPERATOR");
  IElementType BEGIN = new ModulaTokenType("BEGIN");
  IElementType BIG = new ModulaTokenType("BIG");
  IElementType BITWISE_AND = new ModulaTokenType("BITWISE_AND");
  IElementType BITWISE_NOT = new ModulaTokenType("BITWISE_NOT");
  IElementType BITWISE_OR = new ModulaTokenType("BITWISE_OR");
  IElementType BITWISE_XOR = new ModulaTokenType("BITWISE_XOR");
  IElementType BY = new ModulaTokenType("BY");
  IElementType CASE = new ModulaTokenType("CASE");
  IElementType CHAR_CONST = new ModulaTokenType("CHAR_CONST");
  IElementType CLOSE_BRACE = new ModulaTokenType("CLOSE_BRACE");
  IElementType CMPLX = new ModulaTokenType("CMPLX");
  IElementType COMMA = new ModulaTokenType("COMMA");
  IElementType COMMENT = new ModulaTokenType("COMMENT");
  IElementType COMPILER_DIRECTIVE = new ModulaTokenType("COMPILER_DIRECTIVE");
  IElementType COMPILE_TIME_CONDITION = new ModulaTokenType("COMPILE_TIME_CONDITION");
  IElementType COMPILE_TIME_ELSE = new ModulaTokenType("COMPILE_TIME_ELSE");
  IElementType COMPILE_TIME_END = new ModulaTokenType("COMPILE_TIME_END");
  IElementType COMPILE_TIME_IF = new ModulaTokenType("COMPILE_TIME_IF");
  IElementType COMPILE_TIME_INVALID_CODE = new ModulaTokenType("COMPILE_TIME_INVALID_CODE");
  IElementType COMPILE_TIME_THEN = new ModulaTokenType("COMPILE_TIME_THEN");
  IElementType CONST = new ModulaTokenType("CONST");
  IElementType CONTAINS = new ModulaTokenType("CONTAINS");
  IElementType CURLY_BRACE_CLOSE = new ModulaTokenType("CURLY_BRACE_CLOSE");
  IElementType CURLY_BRACE_OPEN = new ModulaTokenType("CURLY_BRACE_OPEN");
  IElementType DEFINITION = new ModulaTokenType("DEFINITION");
  IElementType DIFFERENT = new ModulaTokenType("DIFFERENT");
  IElementType DIVISION = new ModulaTokenType("DIVISION");
  IElementType DLLACCESS = new ModulaTokenType("DLLACCESS");
  IElementType DO = new ModulaTokenType("DO");
  IElementType DOCUMENTATION_COMMENT = new ModulaTokenType("DOCUMENTATION_COMMENT");
  IElementType DOT = new ModulaTokenType("DOT");
  IElementType ELSE = new ModulaTokenType("ELSE");
  IElementType ELSIF = new ModulaTokenType("ELSIF");
  IElementType END = new ModulaTokenType("END");
  IElementType END_OF_STATEMENT = new ModulaTokenType("END_OF_STATEMENT");
  IElementType EQUALITY_OPERATOR = new ModulaTokenType("EQUALITY_OPERATOR");
  IElementType EXIT = new ModulaTokenType("EXIT");
  IElementType EXPORT = new ModulaTokenType("EXPORT");
  IElementType EXTERNAL = new ModulaTokenType("EXTERNAL");
  IElementType FAR = new ModulaTokenType("FAR");
  IElementType FOR = new ModulaTokenType("FOR");
  IElementType FORWARD = new ModulaTokenType("FORWARD");
  IElementType FOR_LOOP_INCREMENT = new ModulaTokenType("FOR_LOOP_INCREMENT");
  IElementType FROM = new ModulaTokenType("FROM");
  IElementType GENERIC = new ModulaTokenType("GENERIC");
  IElementType GREATER_EQUALS = new ModulaTokenType("GREATER_EQUALS");
  IElementType GREATER_THAN = new ModulaTokenType("GREATER_THAN");
  IElementType IDENTIFIER = new ModulaTokenType("IDENTIFIER");
  IElementType IF = new ModulaTokenType("IF");
  IElementType IMPLEMENTATION = new ModulaTokenType("IMPLEMENTATION");
  IElementType IMPORT = new ModulaTokenType("IMPORT");
  IElementType INOUT = new ModulaTokenType("INOUT");
  IElementType INT_CONST_BASE_10 = new ModulaTokenType("INT_CONST_BASE_10");
  IElementType INT_CONST_BASE_16 = new ModulaTokenType("INT_CONST_BASE_16");
  IElementType INT_CONST_BASE_8 = new ModulaTokenType("INT_CONST_BASE_8");
  IElementType LESS_EQUALS = new ModulaTokenType("LESS_EQUALS");
  IElementType LESS_THAN = new ModulaTokenType("LESS_THAN");
  IElementType LOOP = new ModulaTokenType("LOOP");
  IElementType MACRO = new ModulaTokenType("MACRO");
  IElementType MINUS = new ModulaTokenType("MINUS");
  IElementType MODULE = new ModulaTokenType("MODULE");
  IElementType MODULO = new ModulaTokenType("MODULO");
  IElementType NEAR = new ModulaTokenType("NEAR");
  IElementType NOHIGH = new ModulaTokenType("NOHIGH");
  IElementType NOT = new ModulaTokenType("NOT");
  IElementType OF = new ModulaTokenType("OF");
  IElementType OPEN_BRACE = new ModulaTokenType("OPEN_BRACE");
  IElementType OR = new ModulaTokenType("OR");
  IElementType OUT = new ModulaTokenType("OUT");
  IElementType PACKEDSET = new ModulaTokenType("PACKEDSET");
  IElementType PIPE = new ModulaTokenType("PIPE");
  IElementType PLUS = new ModulaTokenType("PLUS");
  IElementType POINTER = new ModulaTokenType("POINTER");
  IElementType POINTER_DEREFERENCE_OPERATOR = new ModulaTokenType("POINTER_DEREFERENCE_OPERATOR");
  IElementType PROCEDURE = new ModulaTokenType("PROCEDURE");
  IElementType PUBLIC = new ModulaTokenType("PUBLIC");
  IElementType PUREASM = new ModulaTokenType("PUREASM");
  IElementType QUALIFIED = new ModulaTokenType("QUALIFIED");
  IElementType RANGE_OPERATOR = new ModulaTokenType("RANGE_OPERATOR");
  IElementType REAL_CONST = new ModulaTokenType("REAL_CONST");
  IElementType RECORD = new ModulaTokenType("RECORD");
  IElementType REMAINDER = new ModulaTokenType("REMAINDER");
  IElementType REPEAT = new ModulaTokenType("REPEAT");
  IElementType RETURN = new ModulaTokenType("RETURN");
  IElementType ROTATE_LEFT = new ModulaTokenType("ROTATE_LEFT");
  IElementType ROTATE_RIGHT = new ModulaTokenType("ROTATE_RIGHT");
  IElementType SET = new ModulaTokenType("SET");
  IElementType SHIFT_ARITHMETIC_RIGHT = new ModulaTokenType("SHIFT_ARITHMETIC_RIGHT");
  IElementType SHIFT_LEFT = new ModulaTokenType("SHIFT_LEFT");
  IElementType SHIFT_RIGHT = new ModulaTokenType("SHIFT_RIGHT");
  IElementType SMALL = new ModulaTokenType("SMALL");
  IElementType SQUARE_BRACE_CLOSE = new ModulaTokenType("SQUARE_BRACE_CLOSE");
  IElementType SQUARE_BRACE_OPEN = new ModulaTokenType("SQUARE_BRACE_OPEN");
  IElementType STRING_CONST_DOUBLE = new ModulaTokenType("STRING_CONST_DOUBLE");
  IElementType STRING_CONST_DOUBLE_ANSI = new ModulaTokenType("STRING_CONST_DOUBLE_ANSI");
  IElementType STRING_CONST_DOUBLE_UNICODE = new ModulaTokenType("STRING_CONST_DOUBLE_UNICODE");
  IElementType STRING_CONST_SINGLE = new ModulaTokenType("STRING_CONST_SINGLE");
  IElementType STRING_CONST_SINGLE_ANSI = new ModulaTokenType("STRING_CONST_SINGLE_ANSI");
  IElementType STRING_CONST_SINGLE_UNICODE = new ModulaTokenType("STRING_CONST_SINGLE_UNICODE");
  IElementType THEN = new ModulaTokenType("THEN");
  IElementType TIMES = new ModulaTokenType("TIMES");
  IElementType TO = new ModulaTokenType("TO");
  IElementType TOKEN_ACHAR = new ModulaTokenType("TOKEN_ACHAR");
  IElementType TOKEN_BITSET = new ModulaTokenType("TOKEN_BITSET");
  IElementType TOKEN_BITSET16 = new ModulaTokenType("TOKEN_BITSET16");
  IElementType TOKEN_BITSET32 = new ModulaTokenType("TOKEN_BITSET32");
  IElementType TOKEN_BOOLEAN = new ModulaTokenType("TOKEN_BOOLEAN");
  IElementType TOKEN_BYTEBOOL = new ModulaTokenType("TOKEN_BYTEBOOL");
  IElementType TOKEN_CARDINAL = new ModulaTokenType("TOKEN_CARDINAL");
  IElementType TOKEN_CARDINAL16 = new ModulaTokenType("TOKEN_CARDINAL16");
  IElementType TOKEN_CARDINAL32 = new ModulaTokenType("TOKEN_CARDINAL32");
  IElementType TOKEN_CARDINAL64 = new ModulaTokenType("TOKEN_CARDINAL64");
  IElementType TOKEN_CHAR = new ModulaTokenType("TOKEN_CHAR");
  IElementType TOKEN_COMPLEX = new ModulaTokenType("TOKEN_COMPLEX");
  IElementType TOKEN_DWORDBOOL = new ModulaTokenType("TOKEN_DWORDBOOL");
  IElementType TOKEN_INTEGER = new ModulaTokenType("TOKEN_INTEGER");
  IElementType TOKEN_INTEGER16 = new ModulaTokenType("TOKEN_INTEGER16");
  IElementType TOKEN_INTEGER32 = new ModulaTokenType("TOKEN_INTEGER32");
  IElementType TOKEN_INTEGER64 = new ModulaTokenType("TOKEN_INTEGER64");
  IElementType TOKEN_LONGCARD = new ModulaTokenType("TOKEN_LONGCARD");
  IElementType TOKEN_LONGCOMPLEX = new ModulaTokenType("TOKEN_LONGCOMPLEX");
  IElementType TOKEN_LONGINT = new ModulaTokenType("TOKEN_LONGINT");
  IElementType TOKEN_LONGREAL = new ModulaTokenType("TOKEN_LONGREAL");
  IElementType TOKEN_REAL = new ModulaTokenType("TOKEN_REAL");
  IElementType TOKEN_SHORTCARD = new ModulaTokenType("TOKEN_SHORTCARD");
  IElementType TOKEN_SHORTINT = new ModulaTokenType("TOKEN_SHORTINT");
  IElementType TOKEN_UCHAR = new ModulaTokenType("TOKEN_UCHAR");
  IElementType TOKEN_WORDBOOL = new ModulaTokenType("TOKEN_WORDBOOL");
  IElementType TYPE = new ModulaTokenType("TYPE");
  IElementType TYPING_OPERATOR = new ModulaTokenType("TYPING_OPERATOR");
  IElementType UNSAFEGUARDED = new ModulaTokenType("UNSAFEGUARDED");
  IElementType UNTIL = new ModulaTokenType("UNTIL");
  IElementType VALUE = new ModulaTokenType("VALUE");
  IElementType VAR = new ModulaTokenType("VAR");
  IElementType VOLATILE = new ModulaTokenType("VOLATILE");
  IElementType WHILE = new ModulaTokenType("WHILE");
  IElementType WITH = new ModulaTokenType("WITH");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == ACTUAL_PARAMETERS) {
        return new ModulaActualParametersImpl(node);
      }
      else if (type == ARRAY_RANGE_TYPE) {
        return new ModulaArrayRangeTypeImpl(node);
      }
      else if (type == ARRAY_TYPE) {
        return new ModulaArrayTypeImpl(node);
      }
      else if (type == ASSIGNMENT) {
        return new ModulaAssignmentImpl(node);
      }
      else if (type == ATTRIBUTE) {
        return new ModulaAttributeImpl(node);
      }
      else if (type == BASIC_TYPE) {
        return new ModulaBasicTypeImpl(node);
      }
      else if (type == BLOCK) {
        return new ModulaBlockImpl(node);
      }
      else if (type == CASE_LABELS) {
        return new ModulaCaseLabelsImpl(node);
      }
      else if (type == CASE_LABEL_LIST) {
        return new ModulaCaseLabelListImpl(node);
      }
      else if (type == CASE_STATEMENT) {
        return new ModulaCaseStatementImpl(node);
      }
      else if (type == CASE_STATEMENTS) {
        return new ModulaCaseStatementsImpl(node);
      }
      else if (type == COMPILATION_UNIT) {
        return new ModulaCompilationUnitImpl(node);
      }
      else if (type == COMPLEX_LITERAL) {
        return new ModulaComplexLiteralImpl(node);
      }
      else if (type == CONSTANT_DECLARATION) {
        return new ModulaConstantDeclarationImpl(node);
      }
      else if (type == DECLARATION) {
        return new ModulaDeclarationImpl(node);
      }
      else if (type == DEFINITIONS) {
        return new ModulaDefinitionsImpl(node);
      }
      else if (type == DEFINITION_MODULE) {
        return new ModulaDefinitionModuleImpl(node);
      }
      else if (type == DESIGNATOR) {
        return new ModulaDesignatorImpl(node);
      }
      else if (type == ELEMENT) {
        return new ModulaElementImpl(node);
      }
      else if (type == ENUMERATION_DEFINITION) {
        return new ModulaEnumerationDefinitionImpl(node);
      }
      else if (type == ENUMERATION_MEMBER_DEFINITION) {
        return new ModulaEnumerationMemberDefinitionImpl(node);
      }
      else if (type == EXPORT_CLAUSE) {
        return new ModulaExportClauseImpl(node);
      }
      else if (type == EXPORT_NAME_DECLARATION) {
        return new ModulaExportNameDeclarationImpl(node);
      }
      else if (type == EXPRESSION) {
        return new ModulaExpressionImpl(node);
      }
      else if (type == EXP_LIST) {
        return new ModulaExpListImpl(node);
      }
      else if (type == FACTOR) {
        return new ModulaFactorImpl(node);
      }
      else if (type == FIELD_LIST) {
        return new ModulaFieldListImpl(node);
      }
      else if (type == FIELD_LIST_SEQUENCE) {
        return new ModulaFieldListSequenceImpl(node);
      }
      else if (type == FORMAL_PARAMETERS) {
        return new ModulaFormalParametersImpl(node);
      }
      else if (type == FORMAL_TYPE) {
        return new ModulaFormalTypeImpl(node);
      }
      else if (type == FORMAL_TYPE_LIST) {
        return new ModulaFormalTypeListImpl(node);
      }
      else if (type == FOR_STATEMENT) {
        return new ModulaForStatementImpl(node);
      }
      else if (type == FP_SECTION) {
        return new ModulaFPSectionImpl(node);
      }
      else if (type == IDENT) {
        return new ModulaIdentImpl(node);
      }
      else if (type == IDENT_LIST) {
        return new ModulaIdentListImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new ModulaIfStatementImpl(node);
      }
      else if (type == IGNORED) {
        return new ModulaIgnoredImpl(node);
      }
      else if (type == IMPORT_CLAUSE) {
        return new ModulaImportClauseImpl(node);
      }
      else if (type == IMPORT_SYMBOL) {
        return new ModulaImportSymbolImpl(node);
      }
      else if (type == INTEGER_LITERAL) {
        return new ModulaIntegerLiteralImpl(node);
      }
      else if (type == LOOP_STATEMENT) {
        return new ModulaLoopStatementImpl(node);
      }
      else if (type == MACRO_DECLARATION) {
        return new ModulaMacroDeclarationImpl(node);
      }
      else if (type == MODULE_DECLARATION) {
        return new ModulaModuleDeclarationImpl(node);
      }
      else if (type == MODULE_HEADER) {
        return new ModulaModuleHeaderImpl(node);
      }
      else if (type == MODULE_IMPORT) {
        return new ModulaModuleImportImpl(node);
      }
      else if (type == MODULE_IMPORT_CLAUSE) {
        return new ModulaModuleImportClauseImpl(node);
      }
      else if (type == MODULE_NAME) {
        return new ModulaModuleNameImpl(node);
      }
      else if (type == NUMBER) {
        return new ModulaNumberImpl(node);
      }
      else if (type == PARAMETER_IDENT_LIST) {
        return new ModulaParameterIdentListImpl(node);
      }
      else if (type == PARAMETER_MODIFIER) {
        return new ModulaParameterModifierImpl(node);
      }
      else if (type == PARAMETER_NAME) {
        return new ModulaParameterNameImpl(node);
      }
      else if (type == PARAMETER_VALUE_MODIFIER) {
        return new ModulaParameterValueModifierImpl(node);
      }
      else if (type == POINTER_TYPE) {
        return new ModulaPointerTypeImpl(node);
      }
      else if (type == PRIORITY) {
        return new ModulaPriorityImpl(node);
      }
      else if (type == PROCEDURE_ATTRIBUTES) {
        return new ModulaProcedureAttributesImpl(node);
      }
      else if (type == PROCEDURE_CALL) {
        return new ModulaProcedureCallImpl(node);
      }
      else if (type == PROCEDURE_DECLARATION) {
        return new ModulaProcedureDeclarationImpl(node);
      }
      else if (type == PROCEDURE_HEADING) {
        return new ModulaProcedureHeadingImpl(node);
      }
      else if (type == PROCEDURE_MODIFIERS) {
        return new ModulaProcedureModifiersImpl(node);
      }
      else if (type == PROCEDURE_TYPE) {
        return new ModulaProcedureTypeImpl(node);
      }
      else if (type == PROGRAM_HEADER) {
        return new ModulaProgramHeaderImpl(node);
      }
      else if (type == PROGRAM_MODULE) {
        return new ModulaProgramModuleImpl(node);
      }
      else if (type == QUALIDENT) {
        return new ModulaQualidentImpl(node);
      }
      else if (type == REAL_LITERAL) {
        return new ModulaRealLiteralImpl(node);
      }
      else if (type == RECORD_TYPE) {
        return new ModulaRecordTypeImpl(node);
      }
      else if (type == RECOVER_END_OF_STATEMENT) {
        return new ModulaRecoverEndOfStatementImpl(node);
      }
      else if (type == RECOVER_WHILE_STATEMENT) {
        return new ModulaRecoverWhileStatementImpl(node);
      }
      else if (type == REPEAT_STATEMENT) {
        return new ModulaRepeatStatementImpl(node);
      }
      else if (type == SET_EXPRESSION) {
        return new ModulaSetExpressionImpl(node);
      }
      else if (type == SET_TYPE) {
        return new ModulaSetTypeImpl(node);
      }
      else if (type == SIMPLE_EXPRESSION) {
        return new ModulaSimpleExpressionImpl(node);
      }
      else if (type == SIMPLE_TYPE) {
        return new ModulaSimpleTypeImpl(node);
      }
      else if (type == STATEMENT) {
        return new ModulaStatementImpl(node);
      }
      else if (type == STATEMENT_SEQUENCE) {
        return new ModulaStatementSequenceImpl(node);
      }
      else if (type == STONY_BROOK_TYPE) {
        return new ModulaStonyBrookTypeImpl(node);
      }
      else if (type == STRING) {
        return new ModulaStringImpl(node);
      }
      else if (type == SUB_RANGE_TYPE) {
        return new ModulaSubRangeTypeImpl(node);
      }
      else if (type == SYMBOL_IMPORT_CLAUSE) {
        return new ModulaSymbolImportClauseImpl(node);
      }
      else if (type == TERM) {
        return new ModulaTermImpl(node);
      }
      else if (type == TYPES) {
        return new ModulaTypesImpl(node);
      }
      else if (type == TYPE_DECLARATION) {
        return new ModulaTypeDeclarationImpl(node);
      }
      else if (type == TYPE_DEFINITION) {
        return new ModulaTypeDefinitionImpl(node);
      }
      else if (type == VARIABLE_DECLARATION) {
        return new ModulaVariableDeclarationImpl(node);
      }
      else if (type == VARIABLE_MODIFIERS) {
        return new ModulaVariableModifiersImpl(node);
      }
      else if (type == VARIABLE_NAME_DEFINITION) {
        return new ModulaVariableNameDefinitionImpl(node);
      }
      else if (type == VARIANT) {
        return new ModulaVariantImpl(node);
      }
      else if (type == WHILE_STATEMENT) {
        return new ModulaWhileStatementImpl(node);
      }
      else if (type == WITH_STATEMENT) {
        return new ModulaWithStatementImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
